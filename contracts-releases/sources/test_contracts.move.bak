#[test_only]
module k3s_daas::test_contracts {
    use k3s_daas::staking::{Self, StakingPool, StakeRecord};
    use k3s_daas::k8s_gateway::{Self, SealToken, ResponseRegistry};
    use sui::test_scenario::{Self};
    use sui::coin::{Self};
    use sui::sui::SUI;
    use std::string;
    use std::vector;

    const ADMIN: address = @0xAD01;
    const USER_1: address = @0xAD02;
    const USER_2: address = @0xAD03;
    const NODE_1: address = @0xAD04;

    #[test]
    fun test_staking_workflow() {
        let scenario_val = test_scenario::begin(ADMIN);
        let scenario = &mut scenario_val;

        // Initialize staking pool
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            staking::init_for_testing(ctx);
        };

        // Test user staking
        test_scenario::next_tx(scenario, USER_1);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let payment = coin::mint_for_testing<SUI>(staking::get_min_user_stake(), ctx);
            staking::stake_for_user(pool, payment, ctx);

            test_scenario::return_shared(pool);
        }

        // Test node staking
        test_scenario::next_tx(scenario, NODE_1);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let payment = coin::mint_for_testing<SUI>(staking::get_min_node_stake(), ctx);
            let node_id = string::utf8(b"test-node-1");
            staking::stake_for_node(pool, payment, node_id, ctx);

            test_scenario::return_shared(pool);
        }

        // Verify staking status
        test_scenario::next_tx(scenario, ADMIN);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);

            // Check user stake
            assert!(staking::has_sufficient_stake(&pool, USER_1, string::utf8(b"user")), 0);

            // Check node stake
            assert!(staking::node_has_stake(&pool, string::utf8(b"test-node-1")), 1);

            // Check total staked
            let expected_total = staking::get_min_user_stake() + staking::get_min_node_stake();
            assert!(staking::get_total_staked(&pool) == expected_total, 2);

            test_scenario::return_shared(pool);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_gateway_initialization() {
        let scenario_val = test_scenario::begin(ADMIN);
        let scenario = &mut scenario_val;

        // Initialize gateway
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            k8s_gateway::init_for_testing(ctx);
        };

        // Verify registry created
        test_scenario::next_tx(scenario, ADMIN);
        {
            let _registry = test_scenario::take_shared<ResponseRegistry>(scenario);
            test_scenario::return_shared(_registry);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_seal_token_creation() {
        let scenario_val = test_scenario::begin(NODE_1);
        let scenario = &mut scenario_val;

        // Initialize both staking and gateway
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            staking::init_for_testing(ctx);
            k8s_gateway::init_for_testing(ctx);
        };

        // Stake for node
        test_scenario::next_tx(scenario, NODE_1);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let payment = coin::mint_for_testing<SUI>(staking::get_min_node_stake(), ctx);
            let node_id = string::utf8(b"test-node-1");
            staking::stake_for_node(pool, payment, node_id, ctx);

            test_scenario::return_shared(pool);
        }

        // Create seal token
        test_scenario::next_tx(scenario, NODE_1);
        {
            let stake_record = test_scenario::take_shared<StakeRecord>(scenario);
            let ctx = test_scenario::ctx(scenario);

            k8s_gateway::create_worker_seal_token(&stake_record, ctx);

            test_scenario::return_shared(stake_record);
        };

        // Verify seal token created
        test_scenario::next_tx(scenario, NODE_1);
        {
            let _token = test_scenario::take_from_sender<SealToken>(scenario);
            test_scenario::return_to_sender(scenario, _token);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_kubectl_command_execution() {
        let scenario_val = test_scenario::begin(NODE_1);
        let scenario = &mut scenario_val;

        // Setup: Initialize contracts and create seal token
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            staking::init_for_testing(ctx);
            k8s_gateway::init_for_testing(ctx);
        };

        test_scenario::next_tx(scenario, NODE_1);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let payment = coin::mint_for_testing<SUI>(staking::get_min_node_stake(), ctx);
            let node_id = string::utf8(b"test-node-1");
            staking::stake_for_node(pool, payment, node_id, ctx);

            test_scenario::return_shared(pool);
        };

        test_scenario::next_tx(scenario, NODE_1);
        {
            let stake_record = test_scenario::take_shared<StakeRecord>(scenario);
            let ctx = test_scenario::ctx(scenario);

            k8s_gateway::create_worker_seal_token(&stake_record, ctx);

            test_scenario::return_shared(stake_record);
        };

        // Test kubectl command execution
        test_scenario::next_tx(scenario, NODE_1);
        {
            let token = test_scenario::take_from_sender<SealToken>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let method = string::utf8(b"GET");
            let path = string::utf8(b"/api/v1/pods");
            let namespace = string::utf8(b"default");
            let resource_type = string::utf8(b"pods");
            let payload = vector::empty<u8>();

            k8s_gateway::execute_kubectl_command(
                &token,
                method,
                path,
                namespace,
                resource_type,
                payload,
                ctx
            );

            test_scenario::return_to_sender(scenario, token);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_permission_checks() {
        let scenario_val = test_scenario::begin(NODE_1);
        let scenario = &mut scenario_val;

        // Setup
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            staking::init_for_testing(ctx);
            k8s_gateway::init_for_testing(ctx);
        };

        test_scenario::next_tx(scenario, NODE_1);
        {
            let pool = test_scenario::take_shared<StakingPool>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let payment = coin::mint_for_testing<SUI>(staking::get_min_node_stake(), ctx);
            let node_id = string::utf8(b"test-node-1");
            staking::stake_for_node(pool, payment, node_id, ctx);

            test_scenario::return_shared(pool);
        };

        test_scenario::next_tx(scenario, NODE_1);
        {
            let stake_record = test_scenario::take_shared<StakeRecord>(scenario);
            let ctx = test_scenario::ctx(scenario);

            k8s_gateway::create_worker_seal_token(&stake_record, ctx);

            test_scenario::return_shared(stake_record);
        };

        // Test permission checks
        test_scenario::next_tx(scenario, NODE_1);
        {
            let token = test_scenario::take_from_sender<SealToken>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let method = string::utf8(b"GET");
            let resource_type = string::utf8(b"pods");

            // Should have read permission for pods
            assert!(k8s_gateway::check_permission_quick(&token, method, resource_type, ctx), 0);

            test_scenario::return_to_sender(scenario, token);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_response_registry() {
        let scenario_val = test_scenario::begin(ADMIN);
        let scenario = &mut scenario_val;

        // Initialize gateway
        test_scenario::next_tx(scenario, ADMIN);
        {
            let ctx = test_scenario::ctx(scenario);
            k8s_gateway::init_for_testing(ctx);
        };

        // Test response storage and retrieval
        test_scenario::next_tx(scenario, ADMIN);
        {
            let registry = test_scenario::take_shared<ResponseRegistry>(scenario);
            let ctx = test_scenario::ctx(scenario);

            let request_id = string::utf8(b"test-request-123");
            let status_code = 200u16;
            let body = b"test response body";

            k8s_gateway::store_k8s_response(
                request_id,
                status_code,
                *body,
                registry,
                ctx
            );

            // Check response status
            let (exists, code) = k8s_gateway::get_k8s_response_status(
                string::utf8(b"test-request-123"),
                &registry
            );

            assert!(exists, 0);
            assert!(code == 200, 1);

            test_scenario::return_shared(registry);
        };

        test_scenario::end(scenario_val);
    }

    #[test]
    fun test_staking_minimums() {
        // Test minimum stake requirements
        assert!(staking::get_min_user_stake() == 500000000, 0); // 0.5 SUI
        assert!(staking::get_min_node_stake() == 1000000000, 1); // 1 SUI
        assert!(staking::get_min_admin_stake() == 10000000000, 2); // 10 SUI
    }
}